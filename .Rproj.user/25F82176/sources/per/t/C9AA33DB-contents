### Simulating species distributions with different niche breadths ###

################################
############ Setup #############
################################

# Check for needed packages, and install the missing ones
required.libraries <- c("ape", "maptools", 
                        "ade4", 
                        "devtools", 
                        "subniche", 
                        "weathermetrics", 
                        "ggplot2", "virtualspecies", "raster",
                        "tidyr")
needed.libraries <- required.libraries[!(required.libraries %in% installed.packages()[,"Package"])]

if(length(needed.libraries)) install.packages(needed.libraries)

# Load all required libraries at once
lapply(required.libraries, require, character.only = TRUE)

# install_github("zdealveindy/theta")
# library(theta)

# Source scripts

# getwd()

### Prepare the real landscape

(worldclim <- getData("worldclim", var = "bio", res = 5))
worldclim

Deutschland <- getData("GADM", country = "DEU", level = 0)

crop.Deutschland <- crop(worldclim, extent(Deutschland))
mask.Deutschland <- mask(crop.Deutschland, Deutschland)

## Check that it worked
# plot(mask.Deutschland)
# plot(Deutschland, add=TRUE, lwd=2)

# Simulate species
my.stack <- mask.Deutschland

env.sd <- seq(0.1, 5, length.out = 200) 
# length.out determines the number of species and the range of
# standard deviations of the gaussian response functions to the axes of the PCA.

species.occurrences <- matrix(NA, nrow = dim(my.stack)[1]*dim(my.stack)[2], ncol = length(env.sd))

for(env.sd.i in env.sd){
my.custom.species <- generateSpFromPCA(raster.stack = my.stack, 
                                       sample.points = TRUE,
                                       nb.points = 9000, 
                                       plot = FALSE,
                                       means = c(0, 0), 
                                       sds = c(env.sd.i, env.sd.i))

PresAbs.raster <- convertToPA(my.custom.species, 
                              PA.method = "probability", 
                              beta = 0.4, alpha = -0.05, 
                              plot = FALSE)

species.occurrences[, which(env.sd == env.sd.i)] <- as.vector(PresAbs.raster$pa.raster)
}

colnames(species.occurrences) <- sapply(env.sd, function(x) paste("sp_", x, sep = "") )

## Environmental matrix

environmental.variables <- matrix(NA, 
                                  nrow = dim(my.stack)[1]*dim(my.stack)[2], 
                                  ncol = dim(my.stack)[3])

for(i in 1:dim(my.stack)[3]){
environmental.variables[,i] <- as.vector(my.stack[[i]])
}

colnames(environmental.variables) <- names(my.stack)
# colMeans(environmental.variables, na.rm = TRUE)

## Prepare dataset
environmental.variables <- as.data.frame(environmental.variables)
species.occurrences <- as.data.frame(species.occurrences)

# Identify rows that have NA
# rows.NA <- row.names(which(is.na(environmental.variables), arr.ind=TRUE))
rows.NA <- row.names(environmental.variables[rowSums(is.na(environmental.variables)) > 0,])
length(unique(rows.NA))
length(rows.NA) - nrow(environmental.variables)

# Remove rows from the Env matrix based on the rows.NA
Env. <- environmental.variables[!(rownames(environmental.variables) %in% rows.NA), ] 

# Check if everything went well
nrow(Env.) + length(unique(rows.NA))

# Remove the same rows from the community matrix 
new.Comm <- species.occurrences[!(rownames(species.occurrences) %in% rows.NA), ] 
nrow(new.Comm); nrow(Env.)

# Remove species (i.e. columns) that have sum zero
Comm <- new.Comm[,colSums(new.Comm) != 0]

ncol(new.Comm)
ncol(Comm)

Env <- Env.

### OMI analysis

##########################################################################################################
############## Running Outlying Mean Index analysis to extract marginality and niche breadth #############
##########################################################################################################

# DolÃ©dec, S., Chessel, D. and Gimaret, C. (2000) 
# Niche separation in community analysis: a new method. Ecology, 81, 2914-1927.

# Outlying Mean Index makes no assumption about the shape of species
# response curves to the environment (e.g. unimodal or linear) and, unlike
# CCA and RDA, gives equal weight to species-rich and species-poor sites.

# You will need two different datasets: one presence-absence matrx (PAM) and a environmental matrix (ENV). 
# Each row of both matrices correspond to a same site (for example, grid cell, or location).
# In the PAM, each column represents a species, and at the ENV matrix, each column corresponds to a environmental variable.

# Prior to the OMI analysis, we must apply a PCA on a correlation matrix to analyse our environmental data.
# Pay attention to the scannf argument.

pca.Env <- dudi.pca(Env,
                    row.w = rep(1, nrow(Env))/nrow(Env),
                    col.w = rep(1, ncol(Env)), 
                    center = TRUE, 
                    scale = TRUE, 
                    scannf = FALSE, nf = 2)

# plot(apply(pca.Env$li, 2, var), pca.Env$eig)

scatter(pca.Env)

# Explore the proportion of the variation associated to each axis of the PCA by:
(percentage.pca <-  100 * pca.Env$eig/sum(pca.Env$eig))

# The correlations between environmental variables and PCA axes (i.e. can be found by):
(correlations.pca <- pca.Env$co)

# Proceed to perfom a the outlying mean index analysis on the distribution of species and the environmental gradient 
# extracted on the previous step 

# Pay attention to the scannf argument.
omi. <- niche(pca.Env, Comm, scannf=FALSE)

# omi.

# Check ?niche to decide which returned objects you are going to use in further analyses

# The percentage of variation of the relationship between species and environmental gradients
# along the axes you have chosen can be found by:

(perc.omi <- 100 * omi.$eig/sum(omi.$eig))

# You can test the significance of the OMI values using a Monte-Carlo permutation test
# krandtest_omi<-rtest(omi.,10)
# krandtest_omi

omi.param <- niche.param(omi.)

dev.off()

op <- par(cex.main = 1.1, 
          cex.lab = 1.1 , 
          font.lab = 1, 
          cex.axis = 1.1, 
          bty = "n")

plot(env.sd, as.data.frame(omi.param)$Tol,
     xlab = "SD of the Species Response to the Environment",
     ylab = "OMI-Tolerance",
     xlim = round(range(env.sd),1),
     ylim = c(min(as.data.frame(omi.param)$Tol), max(as.data.frame(omi.param)$Tol)+0.1),
     bty = "n", type = "p", pch = 21, bg = "grey")
text(3.1, 0.03, "Real landscape simulation", pos = 4, cex = 0.8)

### Fridley's theta specialization index calculation ####

#### Dataset preparation ####
additive.theta <- calculate.theta(as.data.frame(Comm), method = 'add')

op <- par(cex.main = 1.1, 
          cex.lab = 1.1 , 
          font.lab = 1, 
          cex.axis = 1.1, 
          bty = "n")

plot(env.sd,additive.theta$theta,
     xlab = "SD of the Species Response to the Environment",
     ylab = "Fridley's Theta",
     bty = "n", type = "p", pch = 21, bg = "grey")

text(3.2, 6, "Real landscape simulation", pos = 4, cex = 0.8)


